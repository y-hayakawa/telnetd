/*
  simple telnet server for NEXTSTEP 3.3J running in VirtualBox

  ( most of this code is generated by ChatGPT :)
  
  Yoshinori Hayakawa
  2025-08-05
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <arpa/inet.h>
#if defined(__APPLE__)
  #include <util.h>
#else
  #include <pty.h>
  #include <utmp.h>
#endif

#include <fcntl.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <pwd.h>

#include <iconv.h>

#define PORT 2323
#define MAX_CLIENTS 8
#undef DEBUG

const char *allowed_ips[] = { "127.0.0.1", "172.31.111.5", "172.31.111.9", NULL };

int enable_encoding_conv = 0;
int run_as_daemon = 0;


// SIGCHLD handler
void sigchld_handler(int signo) {
    int status;
    while (waitpid(-1, &status, WNOHANG) > 0) {
        ;
    }
}

ssize_t codeconv(const char *from, const char *to,
    const char *inbuf, size_t inlen, char *outbuf, size_t outlen)
{
    iconv_t cd = iconv_open(to, from); // 例: "UTF-8","EUC-JP"
    if (cd == (iconv_t)-1) return -1;
    size_t inleft = inlen, outleft = outlen;
    char *pin = (char*)inbuf, *pout = outbuf;
    size_t result = iconv(cd, &pin, &inleft, &pout, &outleft);
    iconv_close(cd);
    if (result == (size_t)-1) return -1;
    return outlen - outleft;
}

// クライアント-->サーバ（EUC-J-->UTF-8に変換してPTYに書き込む）
ssize_t write_to_pty(int master_fd, const char *data, size_t len, int conv) {
    char utf8buf[8192];
    ssize_t w = len;
    if (conv) {
        w = codeconv("EUC-JP", "UTF-8", data, len, utf8buf, sizeof(utf8buf));
        if (w < 0) w = 0;
    } else {
        memcpy(utf8buf, data, len); w = len;
    }
    return write(master_fd, utf8buf, w);
}

// サーバ-->クライアント（PTYからのUTF-8-->EUC-JPに変換して送信）
ssize_t send_to_client(int client_fd, const char *data, size_t len, int conv) {
    char eucbuf[8192];
    ssize_t w = len;
    if (conv) {
        w = codeconv("UTF-8", "EUC-JP", data, len, eucbuf, sizeof(eucbuf));
        if (w < 0) w = 0;
    } else {
        memcpy(eucbuf, data, len); w = len;
    }
    return send(client_fd, eucbuf, w, 0);
}

int is_ip_allowed(const char *ip) {
    for (int i=0; allowed_ips[i]; i++)
        if (strcmp(ip, allowed_ips[i]) == 0)
            return 1;
    return 0;
}

int process_telnet_naws(const char *buf, size_t len, int master_fd) {
    // buf[0]=IAC, buf[1]=SB, buf[2]=31, buf[3]=colH, buf[4]=colL, buf[5]=rowH, buf[6]=rowL ...
    if (len < 9) return 0; // IAC SB 31 XX XX YY YY IAC SE
    unsigned char colH = buf[3], colL = buf[4], rowH = buf[5], rowL = buf[6];
    int cols = (colH << 8) | colL;
    int rows = (rowH << 8) | rowL;
    struct winsize ws;
    ws.ws_col = cols;
    ws.ws_row = rows;
    ws.ws_xpixel = 0;
    ws.ws_ypixel = 0;
    if (ioctl(master_fd, TIOCSWINSZ, &ws) == 0) {
        printf("[NAWS] Window size set: %d cols x %d rows\n", cols, rows);
        return 1;
    }
    perror("[NAWS] ioctl TIOCSWINSZ failed");
    return 0;
}

ssize_t telnet_strip_iac_full(const char *in, size_t inlen, char *out, size_t outlen, int master_fd) {
    size_t i = 0, j = 0;
    while (i < inlen && j < outlen) {
        if ((unsigned char)in[i] == 0xFF) { // IAC
            if (i+1 < inlen) {
                unsigned char cmd = (unsigned char)in[i+1];
                if (cmd == 0xFF) { // IAC IAC (データ上の0xFF)
                    out[j++] = 0xFF;
                    i += 2;
                    continue;
                }

                // サブネゴシエーション（IAC SB）
                if (cmd == 0xFA && i+2 < inlen) {
                    unsigned char opt = (unsigned char)in[i+2];
                    // NAWS: オプション番号31
#ifdef DEBUG
                    printf("[IAC] SB opt=%d\n",opt);
#endif
                    if (opt == 31) {
                        // IAC SB 31 XX XX YY YY IAC SE
                        size_t sb_start = i;
                        size_t sb_end = i+3;
                        while (sb_end+1 < inlen) {
                            if ((unsigned char)in[sb_end] == 0xFF && (unsigned char)in[sb_end+1] == 0xF0) break;
                            sb_end++;
                        }
                        if (sb_end+1 < inlen) { // 完全なIAC SEがある場合
#ifdef DEBUG
                            printf("[IAC] NAWS found\n");
#endif
                            // 必要バイト数チェック
                            if (sb_end - sb_start >= 6) {
                                process_telnet_naws(&in[sb_start], sb_end-sb_start+2, master_fd);
                            }
                            i = sb_end+2; // IAC SEまでスキップ
                            continue;
                        } else {
#ifdef DEBUG
                            printf("[IAC] incomple NAWS\n");
#endif
                            break;
                        }
                    } else {
                        // 他のサブネゴシエーションもIAC SEまでスキップ
                        size_t sb_end = i+3;
                        while (sb_end+1 < inlen) {
                            if ((unsigned char)in[sb_end] == 0xFF && (unsigned char)in[sb_end+1] == 0xF0) break;
                            sb_end++;
                        }
                        i = (sb_end+1 < inlen) ? sb_end+2 : inlen;
                        continue;
                    }
                }
                
                // 単純コマンド（2バイト）：IAC + コマンド
                if (cmd >= 0xF0 && cmd <= 0xFA) { // 例: SE, NOP, DM, BRK, IP, AO, AYT, EC, EL, GA, SB
                    // サブネゴシエーション開始 (IAC SB [option] ... IAC SE)
                    if (cmd == 0xFA) { // SB
                        i += 2;
                        // IAC SE までスキップ
                        while (i+1 < inlen) {
                            if ((unsigned char)in[i] == 0xFF && (unsigned char)in[i+1] == 0xF0) {
                                i += 2;
                                break;
                            }
                            i++;
                        }
                        continue;
                    } else {
                        i += 2; // 他は2バイトでスキップ
                        continue;
                    }
                }

                // WILL/WONT/DO/DONT系 (3バイト): IAC + コマンド + option
                if (cmd == 0xFB || cmd == 0xFC || cmd == 0xFD || cmd == 0xFE) {
                    i += 3;
                    continue;
                }
                // 未知の場合もスキップ
                i += 2;
                continue;
            } else {
                break; // 不完全なIAC列
            }
        } else {
            out[j++] = in[i++];
        }
    }
    return j;
}

void handle_client(int client_fd, const char *client_ip) {
    int master_fd, slave_fd;
    pid_t shell_pid;
    struct winsize ws = {24, 80, 0, 0};

    printf("[child %d] Handling client %s\n", getpid(), client_ip);

    if (openpty(&master_fd, &slave_fd, NULL, NULL, &ws) < 0) {
        perror("[child] openpty failed");
        close(client_fd);
        return;
    }
    printf("[child %d] openpty: master=%d, slave=%d\n", getpid(), master_fd, slave_fd);

    shell_pid = fork();
    if (shell_pid < 0) {
        perror("[child] fork failed");
        close(master_fd); close(slave_fd); close(client_fd);
        return;
    }
    if (shell_pid == 0) {
        // --- 子プロセス: ptyのslaveでシェルを起動 ---
        close(master_fd);
        if (login_tty(slave_fd) < 0) {
            _exit(100);
        }
        struct passwd *pw = getpwuid(getuid());
        if (pw && pw->pw_dir) {
            chdir(pw->pw_dir);
        }
        setenv("TERM", "vt100", 1);
        execl("/bin/bash", "bash", "-i", NULL);
        _exit(101); // exec失敗
    }
    close(slave_fd);
    printf("[child %d] forked shell PID: %d\n", getpid(), shell_pid);

    // telnetオプション交渉
    char will_echo[] = { 255, 251, 1 };  // IAC WILL ECHO
    char will_sga[]  = { 255, 251, 3 };  // IAC WILL SUPPRESS-GO-AHEAD
    ssize_t x = send(client_fd, will_echo, sizeof(will_echo), 0);
    printf("[child %d] send WILL ECHO: %zd bytes\n", getpid(), x);
    x = send(client_fd, will_sga, sizeof(will_sga), 0);
    printf("[child %d] send WILL SUPPRESS-GO-AHEAD: %zd bytes\n", getpid(), x);

    char do_naws[] = { 255, 253, 31 }; // IAC DO 31
    send(client_fd, do_naws, sizeof(do_naws), 0);

    fd_set rfds;
    char buf[4096], tbuf[4096];
    FILE *ptylog = fopen("/tmp/pty-out.log", "a");
    if (!ptylog) perror("fopen /tmp/pty-out.log");

    while (1) {
        FD_ZERO(&rfds);
        FD_SET(client_fd, &rfds);
        FD_SET(master_fd, &rfds);
        int maxfd = client_fd > master_fd ? client_fd : master_fd;
        int sret = select(maxfd + 1, &rfds, NULL, NULL, NULL);
        if (sret < 0) {
            perror("[child] select failed");
            break;
        }
        // クライアント-->シェル
        if (FD_ISSET(client_fd, &rfds)) {
            ssize_t r = recv(client_fd, buf, sizeof(buf), 0);
            if (r < 0) {
                perror("[child] recv from client failed");
                break;
            }
            if (r == 0) {
                printf("[child %d] client closed connection\n", getpid());
                break;
            }
#ifdef DEBUG
            printf("[child %d] first recv (hex):", getpid());
            for (ssize_t i=0; i<r; i++) printf(" %02x", (unsigned char)buf[i]);
            printf("\n");
#endif
            ssize_t w = telnet_strip_iac_full(buf, r, tbuf, sizeof(tbuf), master_fd);
            if (w == 2 && tbuf[0] == 0x0d && tbuf[1] == 0x00) {
                tbuf[0] = 0x0a; // LF
                w = 1;
            }
#ifdef DEBUG           
            printf("[child %d] recv %zd bytes from client, write %zd bytes to pty\n", getpid(), r, w);
#endif
            ssize_t wrote = write_to_pty(master_fd, tbuf, w, enable_encoding_conv);
            if (wrote < 0) {
                perror("[child] write to pty failed");
                break;
            }
        }
        // シェル-->クライアント
        if (FD_ISSET(master_fd, &rfds)) {
            ssize_t r = read(master_fd, buf, sizeof(buf));
            if (r < 0) {
                perror("[child] read from pty failed");
                if (ptylog) fprintf(ptylog, "[read error] errno=%d (%s)\n", errno, strerror(errno));
                break;
            }
            if (r == 0) {
                printf("[child %d] shell pty closed\n", getpid());
                break;
            }
#ifdef DEBUG            
            if (ptylog) {
                fprintf(ptylog, "[%zd bytes]:", r);
                for (ssize_t i=0; i<r; i++) fprintf(ptylog, " %02x", (unsigned char)buf[i]);
                fprintf(ptylog, "\n");
                fflush(ptylog);
            }
            printf("[child %d] read %zd bytes from pty, send to client\n", getpid(), r);
#endif            
            ssize_t sent = send_to_client(client_fd, buf, r, enable_encoding_conv);
            if (sent < 0) {
                perror("[child] send to client failed");
                break;
            }
        }
    }
    printf("[child %d] cleaning up, closing fds\n", getpid());
    if (ptylog) fclose(ptylog);
    close(master_fd);
    close(client_fd);
    kill(shell_pid, SIGHUP);
    int status = 0;
    waitpid(shell_pid, &status, 0);
    printf("[child %d] shell exited with status %d\n", getpid(), status);
    if (WIFEXITED(status)) {
        printf("[child %d]   normal exit: code=%d\n", getpid(), WEXITSTATUS(status));
    }
    if (WIFSIGNALED(status)) {
        printf("[child %d]   signaled: sig=%d\n", getpid(), WTERMSIG(status));
    }
}

int main(int argc, char *argv[]) {

    for (int argi = 1; argi < argc; ++argi) {
        if (strcmp(argv[argi], "-j") == 0 || strcmp(argv[argi], "--japan") == 0) {
            enable_encoding_conv = 1;
            printf("Encoding conversion (EUC-JP <-> UTF-8) enabled\n");
        }
        if (strcmp(argv[argi], "-d") == 0 || strcmp(argv[argi], "--daemon") == 0) {
            run_as_daemon = 1;
        }
    }

    struct sigaction sa;
    sa.sa_handler = sigchld_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART; 
    sigaction(SIGCHLD, &sa, NULL);

    if (run_as_daemon) {
        pid_t pid = fork();
        if (pid < 0) exit(1);
        if (pid > 0) exit(0); // 親プロセス終了
        setsid();
        chdir("/");
        umask(0);
        close(0); close(1); close(2);
        open("/dev/null", O_RDWR); // stdin
        dup(0); // stdout
        dup(0); // stderr
    }
    
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket failed");
        exit(1);
    }
    int yes = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(PORT);
    if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind failed");
        exit(1);
    }
    if (listen(sockfd, MAX_CLIENTS) < 0) {
        perror("listen failed");
        exit(1);
    }

    printf("telnet server: waiting on port %d\n", PORT);
    while (1) {
        struct sockaddr_in cli_addr;
        socklen_t len = sizeof(cli_addr);
        int client_fd = accept(sockfd, (struct sockaddr*)&cli_addr, &len);
        if (client_fd < 0) {
            perror("accept failed");
            continue;
        }
        char ipbuf[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &cli_addr.sin_addr, ipbuf, sizeof(ipbuf));
        printf("connection from %s\n", ipbuf);
        if (!is_ip_allowed(ipbuf)) {
            printf("connection from %s denied\n", ipbuf);
            close(client_fd);
            continue;
        }
        printf("accepted from %s (pid=%d)\n", ipbuf, getpid());
        pid_t pid = fork();
        if (pid < 0) {
            perror("fork failed");
            close(client_fd);
            continue;
        }
        if (pid == 0) {
            close(sockfd);
            handle_client(client_fd, ipbuf);
            exit(0);
        }
        close(client_fd);
    }
    close(sockfd);
    return 0;
}
